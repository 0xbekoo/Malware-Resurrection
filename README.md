## Malware Resurrection

Welcome to the Malware Resurrection Project. In this technique, I'm going to talk about a technique that aims to revive malware if it is deleted from the system. Welcome to the Malware Resurrection Project. In this technique, I'm going to talk about a technique that aims to resurrect malware if it is deleted from the system.

> [!Warning]
> Please note that the content of this repository is intended for educational purposes only. I do not endorse or encourage any illegal activities. The techniques and methods demonstrated here should not be used for malicious purposes or in any unauthorized scenarios. 

## ❓What's Malware Resurrection

Malware Resurrection refers to techniques used to revive and maintain the presence of malware within a system, ensuring that it continues to operate even if it is removed or terminated. The goal of malware resurrection is to establish persistence and ensure that the malware can reappear or re-launch after being removed.

- **1. Re-Downloading and Re-Executing Payloads**
  - **Mechanism:** The malware may use a user-mode program or scheduled tasks to periodically check for its presence. If the malware is detected as missing, the program can re-download and reinstall it from a remote server or hidden location on the system.
Registry Persistence:

- **2.Registry Persistence**
  - **Mechanism:** The malware may modify or create registry entries to ensure it is executed on system startup. Common registry locations include:
    - **Run Keys:** HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run 
    - **Startup Folder:** Adding shortcuts to the malware executable in the Startup folder, ensuring it runs automatically when the user logs in.

- **3.Scheduled Tasks**
  - **Mechanism:** Malware may create scheduled tasks or cron jobs that periodically execute the malware or related components. These tasks are set to run at specific times or events, such as system startup or user login, ensuring the malware reactivates if removed.

- **4.Kernel-Level Persistence**
  - **Mechanism:** Advanced malware may use kernel-mode drivers to embed itself deeply within the operating system. This can involve:
    - Rootkits: Modifying kernel data structures to hide files, processes, or network connections.
    - Driver Installation: Installing and maintaining a driver that ensures malware persists at a low level.

## 📁Project

The application I've developed is designed to ensure that malware remains active and concealed within a system, utilizing both user-mode and kernel-mode components. This dual approach enables the application to persistently hide and relaunch malware, while evading detection from standard system tools.

### 1. Usermode Program

The primary function of the user-mode program is to monitor and maintain the presence of the malware. If it detects that the malware has been terminated or removed, it springs into action. The user-mode program communicates with the kernel-mode driver to facilitate the reinstallation and concealment of the malware.

### 2. Kernel-Mode Driver

Upon instruction from the user-mode program, the driver creates a hidden directory on the system, typically within a critical location such as C:\Windows\System32. This directory is used to store the malware executable in a manner that is difficult for standard file explorers or system administrators to detect.

### Workflow
- **Monitoring and Recovery:** The user-mode program continuously listens for the presence of the malware process. If the process is terminated for any reason, the program alerts the driver.

- **Hidden File Creation:** The kernel-mode driver responds by creating a hidden file path within the specified directory. This ensures that the new malware file is hidden at the OS level before it is even downloaded.

- **Malware Restoration:** Once the file path is in place, the user-mode program downloads the malware to the hidden directory and immediately spawns a new process for it.

- **Process Concealment (DKOM Attack):** To ensure that the malware runs undetected, the user-mode program passes the Process ID (PID) of the newly created malware process to the driver. The driver then uses Direct Kernel Object Manipulation (DKOM) to remove the malware’s PID from the system’s process list, making it invisible to tools like Task Manager and other process monitoring utilities.

## :heavy_exclamation_mark:Important Considerations Before Running the Project

> [!Important]
> To run this project successfully, you need to execute it on a Windows system in Test Mode. This mode allows the system to load unsigned drivers, which is necessary for the kernel-mode components of the application. Additionally, it is highly recommended to use WinDbg for debugging and closely inspecting the results.

Assuming you have access to development tools such as Visual Studio and the Windows Driver Kit (WDK), you will need to compile the driver and user-mode program yourself. Note that I will not be providing any files with .exe or .sys extensions.

Take a look at both the driver code and the project code and you will find variables that are important:

### User-mode Program

In the user-mode program code, you will find the following important variables:

```c
CHAR ExecutablePath[0x80] = "C:\\Windows\\System32";
CHAR ExecutableName[0x80] = "malwarename.exe";
CHAR ExecutableUrl[0x80] = "https://url";
```

### Kernel-mode Driver:

In the kernel-mode driver code, you will encounter:

```c
UNICODE_STRING G_ExecutablePath = RTL_CONSTANT_STRING(L"\\??\\C:\\Windows\\System32\\");
```

### Editing and Compiling Instructions

#### User-Mode Program

- **ExecutablePath:** Ensure that you do not add a trailing backslash (\\) at the end of the path.
- **ExecutableName:** Specify the name of the executable file you intend to use.
- **ExecutableUrl:** Provide the URL from which the executable will be downloaded.
  
#### Kernel-Mode Driver

- **ExecutablePath:** Maintain the \\??\\ prefix and avoid adding a trailing backslash (\) at the end of the path.
  
Feel free to modify these values according to your needs. Ensure that paths and URLs are correctly formatted to avoid any issues during compilation and execution.
